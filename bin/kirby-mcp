#!/usr/bin/env -S php -d display_errors=0 -d display_startup_errors=0
<?php

declare(strict_types=1);

$prepend = __DIR__ . '/../src/Cli/kirby-cli-prepend.php';
if (is_file($prepend)) {
    require_once $prepend;
} else {
    if (!defined('KIRBY_HELPER_DUMP')) {
        define('KIRBY_HELPER_DUMP', false);
    }

    if (!defined('KIRBY_HELPER_E')) {
        define('KIRBY_HELPER_E', false);
    }
}

$autoloadPath = $GLOBALS['_composer_autoload_path'] ?? null;

if (is_string($autoloadPath) && $autoloadPath !== '' && is_file($autoloadPath)) {
    require_once $autoloadPath;
} elseif (is_file(dirname(__DIR__, 3) . '/autoload.php')) {
    require_once dirname(__DIR__, 3) . '/autoload.php';
} else {
    require_once __DIR__ . '/../vendor/autoload.php';
}

use Bnomei\KirbyMcp\Install\RuntimeCommandsInstaller;
use Bnomei\KirbyMcp\Mcp\Handlers\RequireInitForToolsHandler;
use Bnomei\KirbyMcp\Mcp\Handlers\SetLogLevelHandler;
use Bnomei\KirbyMcp\Mcp\ProjectContext;
use Bnomei\KirbyMcp\Mcp\Resources\CliResources;
use Bnomei\KirbyMcp\Mcp\Resources\UpdateSchemaResources;
use Bnomei\KirbyMcp\Mcp\Resources\ExtensionReferenceResources;
use Bnomei\KirbyMcp\Mcp\Resources\GlossaryResources;
use Bnomei\KirbyMcp\Mcp\Resources\HookReferenceResources;
use Bnomei\KirbyMcp\Mcp\Resources\PanelReferenceResources;
use Bnomei\KirbyMcp\Docs\ExtensionReferenceIndex;
use Bnomei\KirbyMcp\Docs\HookReferenceIndex;
use Bnomei\KirbyMcp\Docs\PanelReferenceIndex;
use Bnomei\KirbyMcp\Mcp\Support\KbDocuments;
use Bnomei\KirbyMcp\Mcp\Tools\IdeTools;
use Bnomei\KirbyMcp\Mcp\Support\JsonMarkers;
use Bnomei\KirbyMcp\Project\ProjectRootFinder;
use Mcp\Capability\Registry;
use Mcp\Capability\Registry\Container;
use Mcp\Capability\Registry\ReferenceHandler;
use Mcp\Server;
use Mcp\Server\Builder as McpServerBuilder;
use Mcp\Server\Handler\Request\CallToolHandler;
use Mcp\Schema\Annotations;
use Mcp\Schema\Resource;
use Mcp\Schema\Enum\Role;
use Mcp\Schema\ServerCapabilities;
use Mcp\Server\Transport\StdioTransport;

$projectRoot = null;
$projectFlagProvided = false;
$subcommand = null;

for ($index = 1; $index < count($argv); $index++) {
    $arg = $argv[$index] ?? null;
    if (!is_string($arg)) {
        continue;
    }

    if ($arg === 'install' || $arg === 'update' || $arg === 'ide:status' || $arg === 'ide:generate') {
        $subcommand = $arg;
        continue;
    }

    if (str_starts_with($arg, '--project=')) {
        $projectFlagProvided = true;
        $projectRoot = substr($arg, strlen('--project='));
        continue;
    }

    if ($arg === '--project') {
        $projectFlagProvided = true;
        $next = $argv[$index + 1] ?? null;
        if (is_string($next) && $next !== '' && !str_starts_with($next, '--')) {
            $projectRoot = $next;
            $index++;
        }
        continue;
    }
}

if (is_string($projectRoot) && $projectRoot !== '') {
    $resolved = realpath($projectRoot) ?: $projectRoot;
    putenv('KIRBY_MCP_PROJECT_ROOT=' . $resolved);
} elseif (getenv('KIRBY_MCP_PROJECT_ROOT') === false || getenv('KIRBY_MCP_PROJECT_ROOT') === '') {
    $detected = (new ProjectRootFinder())->findKirbyProjectRoot();
    if (is_string($detected) && $detected !== '') {
        putenv('KIRBY_MCP_PROJECT_ROOT=' . $detected);
    } elseif ($projectFlagProvided === true) {
        // The user explicitly asked for project auto-detection with `--project`
        // but we could not find a composer-based Kirby project root.
        // Avoid writing to stdout/stderr because this is a stdio protocol server.
    }
}

if ($subcommand === 'install' || $subcommand === 'update') {
    $root = getenv('KIRBY_MCP_PROJECT_ROOT');
    $root = is_string($root) && $root !== '' ? $root : null;

    if ($root === null) {
        $detected = (new ProjectRootFinder())->findKirbyProjectRoot();
        $root = is_string($detected) && $detected !== '' ? $detected : null;
    }

    if ($root === null) {
        fwrite(STDERR, "Kirby MCP: unable to determine Kirby project root. Use --project=/path/to/kirby-project.\n");
        exit(1);
    }

    $force = in_array('--force', $argv, true);
    $json = in_array('--json', $argv, true);

    $configResult = [
        'path' => null,
        'created' => false,
        'skipped' => false,
        'error' => null,
    ];

    $configDir = rtrim($root, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR . '.kirby-mcp';
    $configPath = $configDir . DIRECTORY_SEPARATOR . 'mcp.json';
    $altConfigPath = $configDir . DIRECTORY_SEPARATOR . 'config.json';

    if (is_file($configPath) || is_file($altConfigPath)) {
        $configResult['path'] = is_file($configPath) ? $configPath : $altConfigPath;
        $configResult['skipped'] = true;
    } else {
        if (!is_dir($configDir) && !mkdir($configDir, 0777, true) && !is_dir($configDir)) {
            $configResult['path'] = $configPath;
            $configResult['error'] = 'Failed to create directory: ' . $configDir;
        } else {
            $contents = json_encode([
                'cache' => [
                    'ttlSeconds' => 60,
                ],
                'docs' => [
                    'ttlSeconds' => 86400,
                ],
                'dumps' => [
                    'enabled' => true,
                    'maxBytes' => 2097152,
                ],
                'cli' => [
                    'allow' => [],
                    'allowWrite' => [],
                    'deny' => [],
                ],
                'ide' => [
                    'typeHintScanBytes' => 16384,
                ],
            ], JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES);

            if (!is_string($contents)) {
                $configResult['path'] = $configPath;
                $configResult['error'] = 'Failed to encode JSON for config file.';
            } else {
                $written = file_put_contents($configPath, $contents . "\n");
                if ($written === false) {
                    $configResult['path'] = $configPath;
                    $configResult['error'] = 'Failed to write config file: ' . $configPath;
                } else {
                    $configResult['path'] = $configPath;
                    $configResult['created'] = true;
                }
            }
        }
    }

    $writeMode = $subcommand === 'update' ? true : $force;

    $installer = new RuntimeCommandsInstaller();
    $installResult = null;
    $installError = null;

    try {
        $installResult = $installer->install(projectRoot: $root, force: $writeMode);
    } catch (Throwable $exception) {
        $installError = $exception->getMessage();

        $fallbackRoot = rtrim($root, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR . 'site' . DIRECTORY_SEPARATOR . 'commands';
        try {
            $installResult = $installer->install(
                projectRoot: $root,
                force: $writeMode,
                commandsRootOverride: $fallbackRoot,
            );
        } catch (Throwable $fallbackException) {
            $installError = $installError . ' | Fallback failed: ' . $fallbackException->getMessage();
        }
    }

    if ($installResult === null) {
        $payload = [
            'ok' => false,
            'command' => $subcommand,
            'projectRoot' => $root,
            'error' => $installError ?? 'Runtime commands install failed.',
            'config' => $configResult,
        ];

        if ($json === true) {
            echo JsonMarkers::START . "\n";
            echo json_encode($payload, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES) . "\n";
            echo JsonMarkers::END . "\n";
        } else {
            fwrite(STDERR, "Kirby MCP {$subcommand}\n");
            fwrite(STDERR, "Project: {$root}\n");
            fwrite(STDERR, "Error: " . ($payload['error'] ?? 'Runtime commands install failed.') . "\n");
        }

        exit(1);
    }

    $payload = [
        'ok' => $installResult->errors === [] && $configResult['error'] === null,
        'command' => $subcommand,
        'projectRoot' => $installResult->projectRoot,
        'commandsRoot' => $installResult->commandsRoot,
        'installed' => $installResult->installed,
        'skipped' => $installResult->skipped,
        'errors' => $installResult->errors,
        'config' => $configResult,
    ];

    if ($json === true) {
        echo JsonMarkers::START . "\n";
        echo json_encode($payload, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES) . "\n";
        echo JsonMarkers::END . "\n";
    } else {
        echo "Kirby MCP {$subcommand}\n";
        echo "Project: {$installResult->projectRoot}\n";
        echo "Runtime commands target: " . rtrim($installResult->commandsRoot, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR . "mcp\n";
        echo "Runtime commands installed: " . count($installResult->installed) . "\n";
        echo "Runtime commands skipped: " . count($installResult->skipped) . "\n";

        if ($configResult['created'] === true && is_string($configResult['path'])) {
            echo "Config created: {$configResult['path']}\n";
        } elseif ($configResult['skipped'] === true && is_string($configResult['path'])) {
            echo "Config exists: {$configResult['path']}\n";
        } elseif (is_string($configResult['error'])) {
            echo "Config error: {$configResult['error']}\n";
        }

        if ($installResult->errors !== []) {
            echo "Runtime command install errors:\n";
            foreach ($installResult->errors as $error) {
                echo "- {$error['path']}: {$error['error']}\n";
            }
        }

        echo "\n";
        echo "Next:\n";
        echo "- Start MCP server: vendor/bin/kirby-mcp\n";
        echo "- Check runtime status: vendor/bin/kirby-mcp --project={$installResult->projectRoot} (then call kirby_runtime_status)\n";
    }

    exit($payload['ok'] === true ? 0 : 1);
}

if ($subcommand === 'ide:status' || $subcommand === 'ide:generate') {
    $root = getenv('KIRBY_MCP_PROJECT_ROOT');
    $root = is_string($root) && $root !== '' ? $root : null;

    if ($root === null) {
        $detected = (new ProjectRootFinder())->findKirbyProjectRoot();
        $root = is_string($detected) && $detected !== '' ? $detected : null;
    }

    if ($root === null) {
        fwrite(STDERR, "Kirby MCP: unable to determine Kirby project root. Use --project=/path/to/kirby-project.\n");
        exit(1);
    }

    putenv('KIRBY_MCP_PROJECT_ROOT=' . $root);

    $json = in_array('--json', $argv, true);
    $rawJson = in_array('--raw-json', $argv, true) || in_array('--plain-json', $argv, true);
    $help = in_array('--help', $argv, true) || in_array('-h', $argv, true);

    try {
        $ide = new IdeTools();

        if ($subcommand === 'ide:status') {
            if ($help === true) {
                echo "Kirby MCP ide:status\n";
                echo "Usage: vendor/bin/kirby-mcp ide:status [--project=/path] [--details] [--limit=N] [--json|--raw-json]\n";
                exit(0);
            }

            $withDetails = in_array('--details', $argv, true) || in_array('--with-details', $argv, true);
            $limit = 50;

            for ($index = 1; $index < count($argv); $index++) {
                $arg = $argv[$index] ?? null;
                if (!is_string($arg)) {
                    continue;
                }

                if (str_starts_with($arg, '--limit=')) {
                    $value = substr($arg, strlen('--limit='));
                    $parsed = filter_var($value, FILTER_VALIDATE_INT);
                    if ($parsed !== false) {
                        $limit = (int) $parsed;
                    }
                    continue;
                }

                if ($arg === '--limit') {
                    $next = $argv[$index + 1] ?? null;
                    $parsed = is_string($next) ? filter_var($next, FILTER_VALIDATE_INT) : false;
                    if ($parsed !== false) {
                        $limit = (int) $parsed;
                        $index++;
                    }
                    continue;
                }
            }

            $status = $ide->ideHelpersStatus(withDetails: $withDetails, limit: $limit);

            if ($rawJson === true) {
                echo json_encode($status, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE) . "\n";
                exit(0);
            }

            if ($json === true) {
                echo JsonMarkers::START . "\n";
                echo json_encode($status, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE) . "\n";
                echo JsonMarkers::END . "\n";
                exit(0);
            }

            echo "Kirby MCP ide:status\n";
            echo "Project: {$status['projectRoot']}\n";
            if (is_string($status['host'] ?? null) && $status['host'] !== '') {
                echo "Host: {$status['host']}\n";
            }

            $templates = $status['templates'] ?? [];
            $snippets = $status['snippets'] ?? [];
            $controllers = $status['controllers'] ?? [];
            $pageModels = $status['pageModels'] ?? [];

            echo "Templates: " . ($templates['withKirbyVarHints'] ?? 0) . "/" . ($templates['total'] ?? 0) . " with @var hints\n";
            echo "Snippets: " . ($snippets['withKirbyVarHints'] ?? 0) . "/" . ($snippets['total'] ?? 0) . " with @var hints\n";
            echo "Controllers: " . ($controllers['withKirbyTypeHints'] ?? 0) . "/" . ($controllers['closureControllers'] ?? 0) . " typed closures\n";
            echo "Page models: " . ($pageModels['withKirbyTypeHints'] ?? 0) . "/" . ($pageModels['pageModelFiles'] ?? 0) . " typed models\n";

            $helpers = $status['helpers'] ?? [];
            if (is_array($helpers) && $helpers !== []) {
                echo "Helpers:\n";
                foreach ($helpers as $helper) {
                    if (!is_array($helper)) {
                        continue;
                    }
                    $path = $helper['path'] ?? '';
                    $exists = ($helper['exists'] ?? false) === true ? 'yes' : 'no';
                    $stale = ($helper['stale'] ?? null) === true ? 'stale' : 'fresh';
                    if (($helper['exists'] ?? false) !== true) {
                        $stale = 'n/a';
                    }
                    echo "- {$path} (exists: {$exists}, {$stale})\n";
                }
            }

            $recs = $status['recommendations'] ?? [];
            if (is_array($recs) && $recs !== []) {
                echo "Recommendations:\n";
                foreach ($recs as $rec) {
                    if (is_string($rec) && $rec !== '') {
                        echo "- {$rec}\n";
                    }
                }
            }

            exit(0);
        }

        if ($subcommand === 'ide:generate') {
            if ($help === true) {
                echo "Kirby MCP ide:generate\n";
                echo "Usage: vendor/bin/kirby-mcp ide:generate [--project=/path] [--write] [--dry-run] [--force] [--prefer-runtime|--prefer-filesystem] [--json|--raw-json]\n";
                echo "Defaults: --dry-run --prefer-runtime\n";
                exit(0);
            }

            $dryRun = true;
            if (in_array('--write', $argv, true)) {
                $dryRun = false;
            } elseif (in_array('--dry-run', $argv, true)) {
                $dryRun = true;
            }

            $force = in_array('--force', $argv, true);

            $preferRuntime = true;
            if (in_array('--prefer-filesystem', $argv, true) || in_array('--filesystem', $argv, true)) {
                $preferRuntime = false;
            } elseif (in_array('--prefer-runtime', $argv, true) || in_array('--runtime', $argv, true)) {
                $preferRuntime = true;
            }

            $result = $ide->generateIdeHelpers(dryRun: $dryRun, force: $force, preferRuntime: $preferRuntime);

            if ($rawJson === true) {
                echo json_encode($result, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE) . "\n";
                exit(($result['ok'] ?? false) === true ? 0 : 1);
            }

            if ($json === true) {
                echo JsonMarkers::START . "\n";
                echo json_encode($result, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE) . "\n";
                echo JsonMarkers::END . "\n";
                exit(($result['ok'] ?? false) === true ? 0 : 1);
            }

            echo "Kirby MCP ide:generate\n";
            echo "Project: {$result['projectRoot']}\n";
            echo "Dry run: " . (($result['dryRun'] ?? false) === true ? 'yes' : 'no') . "\n";
            echo "Source: {$result['source']}\n";
            if (is_array($result['sources'] ?? null)) {
                $sources = $result['sources'];
                $blueprints = is_string($sources['blueprints'] ?? null) ? $sources['blueprints'] : null;
                $snippets = is_string($sources['snippets'] ?? null) ? $sources['snippets'] : null;
                if ($blueprints !== null || $snippets !== null) {
                    echo "Sources: blueprints=" . ($blueprints ?? 'n/a') . " snippets=" . ($snippets ?? 'n/a') . "\n";
                }
            }
            echo "Output: {$result['outputDir']}\n";

            $files = $result['files'] ?? [];
            if (is_array($files) && $files !== []) {
                echo "Files:\n";
                foreach ($files as $file) {
                    if (!is_array($file)) {
                        continue;
                    }

                    $action = $file['action'] ?? 'unknown';
                    $path = $file['path'] ?? '';
                    $ok = ($file['ok'] ?? false) === true ? 'ok' : 'error';
                    $reason = $file['reason'] ?? null;
                    $error = $file['error'] ?? null;

                    echo "- {$action}: {$path} ({$ok})\n";
                    if (is_string($reason) && $reason !== '') {
                        echo "  reason: {$reason}\n";
                    }
                    if (is_string($error) && $error !== '') {
                        echo "  error: {$error}\n";
                    }
                }
            }

            $stats = $result['stats'] ?? [];
            if (is_array($stats) && $stats !== []) {
                echo "Stats:\n";
                echo "- blueprints: " . ($stats['blueprints'] ?? 0) . "\n";
                $fields = $stats['fields'] ?? [];
                if (is_array($fields)) {
                    echo "- fields: page=" . ($fields['page'] ?? 0)
                        . " file=" . ($fields['file'] ?? 0)
                        . " user=" . ($fields['user'] ?? 0)
                        . " site=" . ($fields['site'] ?? 0) . "\n";
                }
                $collisions = $stats['collisions'] ?? [];
                if (is_array($collisions)) {
                    echo "- collisions: page=" . ($collisions['page'] ?? 0)
                        . " file=" . ($collisions['file'] ?? 0)
                        . " user=" . ($collisions['user'] ?? 0)
                        . " site=" . ($collisions['site'] ?? 0) . "\n";
                }
            }

            $notes = $result['notes'] ?? [];
            if (is_array($notes) && $notes !== []) {
                echo "Notes:\n";
                foreach ($notes as $note) {
                    if (is_string($note) && $note !== '') {
                        echo "- {$note}\n";
                    }
                }
            }

            exit(($result['ok'] ?? false) === true ? 0 : 1);
        }
    } catch (Throwable $exception) {
        fwrite(STDERR, "Kirby MCP {$subcommand} failed: " . $exception->getMessage() . "\n");
        exit(1);
    }
}

/**
 * @param array<int, string> $paths
 */
function resolveMaxMtime(array $paths): ?int
{
    $latest = null;

    foreach ($paths as $path) {
        if (!is_string($path) || $path === '' || !is_file($path)) {
            continue;
        }

        $mtime = @filemtime($path);
        if (is_int($mtime)) {
            $latest = $latest === null ? $mtime : max($latest, $mtime);
        }
    }

    return $latest;
}

function resolveClassMtime(string $className): ?int
{
    try {
        $reflection = new ReflectionClass($className);
        $path = $reflection->getFileName();
        if (is_string($path) && $path !== '') {
            $mtime = @filemtime($path);
            if (is_int($mtime)) {
                return $mtime;
            }
        }
    } catch (Throwable) {
        return null;
    }

    return null;
}

function resolveKbPrefixMtime(string $prefix): ?int
{
    $kbRoot = KbDocuments::kbRoot();
    if (!is_dir($kbRoot)) {
        return null;
    }

    $projectRoot = KbDocuments::projectRoot();
    $prefix = ltrim($prefix, '/');

    $latest = null;
    $iterator = new RecursiveIteratorIterator(
        new RecursiveDirectoryIterator($kbRoot, FilesystemIterator::SKIP_DOTS)
    );

    foreach ($iterator as $file) {
        if (!$file->isFile() || strtolower($file->getExtension()) !== 'md') {
            continue;
        }

        $name = strtolower($file->getFilename());
        if ($name === 'plan.md' || $name === 'agents.md') {
            continue;
        }

        $path = $file->getPathname();
        $relative = ltrim(substr($path, strlen($projectRoot)), DIRECTORY_SEPARATOR);
        $relative = str_replace(DIRECTORY_SEPARATOR, '/', $relative);

        if (!str_starts_with($relative, $prefix)) {
            continue;
        }

        $mtime = $file->getMTime();
        $latest = $latest === null ? $mtime : max($latest, $mtime);
    }

    return $latest;
}

function resolveProjectMtime(string $projectRoot): ?int
{
    $projectRoot = rtrim($projectRoot, DIRECTORY_SEPARATOR);

    return resolveMaxMtime([
        $projectRoot . DIRECTORY_SEPARATOR . 'composer.json',
        $projectRoot . DIRECTORY_SEPARATOR . 'composer.lock',
        $projectRoot . DIRECTORY_SEPARATOR . 'vendor' . DIRECTORY_SEPARATOR . 'bin' . DIRECTORY_SEPARATOR . 'kirby',
    ]);
}

/**
 * @param array<string, mixed>|array<int, mixed> $payload
 */
function resolveJsonSize(array $payload): ?int
{
    try {
        $encoded = json_encode($payload, JSON_THROW_ON_ERROR | JSON_PRETTY_PRINT);
    } catch (Throwable) {
        return null;
    }

    return is_string($encoded) ? strlen($encoded) : null;
}

/**
 * @return array<string, mixed>|null
 */
function resourceMetaFromMtime(?int $mtime): ?array
{
    if (!is_int($mtime)) {
        return null;
    }

    $formatted = gmdate(DATE_ATOM, $mtime);
    if (!is_string($formatted) || $formatted === '') {
        return null;
    }

    return ['lastModified' => $formatted];
}

/**
 * Register sized resources for resources/list.
 *
 * The size field cannot be dynamic with PHP attributes; registering these resources
 * manually allows us to provide accurate byte sizes and metadata.
 */
function registerSizedMarkdownResources(Registry $registry): void
{
    $defaultAnnotations = new Annotations(
        audience: [Role::Assistant],
        priority: 0.4,
    );
    $importantAnnotations = new Annotations(
        audience: [Role::Assistant],
        priority: 0.5,
    );

    try {
        $contents = (new ExtensionReferenceResources())->extensionsList();
        $registry->registerResource(
            new Resource(
                uri: 'kirby://extensions',
                name: 'extensions',
                description: 'List Kirby plugin extensions (links to kirby://extension/{name}).',
                mimeType: 'text/markdown',
                annotations: $defaultAnnotations,
                size: strlen($contents),
                meta: resourceMetaFromMtime(resolveClassMtime(ExtensionReferenceIndex::class)),
            ),
            [ExtensionReferenceResources::class, 'extensionsList'],
            true,
        );
    } catch (Throwable) {
        // Keep resource available via attribute discovery if sizing fails.
    }

    try {
        $contents = (new HookReferenceResources())->hooksList();
        $registry->registerResource(
            new Resource(
                uri: 'kirby://hooks',
                name: 'hooks',
                description: 'List Kirby plugin hook names (links to kirby://hook/{name}).',
                mimeType: 'text/markdown',
                annotations: $defaultAnnotations,
                size: strlen($contents),
                meta: resourceMetaFromMtime(resolveClassMtime(HookReferenceIndex::class)),
            ),
            [HookReferenceResources::class, 'hooksList'],
            true,
        );
    } catch (Throwable) {
        // Keep resource available via attribute discovery if sizing fails.
    }

    try {
        $panel = new PanelReferenceResources();

        $fields = $panel->fieldsList();
        $registry->registerResource(
            new Resource(
                uri: 'kirby://fields',
                name: 'panel_fields',
                description: 'List Kirby Panel field types (links to kirby://field/{type}).',
                mimeType: 'text/markdown',
                annotations: $defaultAnnotations,
                size: strlen($fields),
                meta: resourceMetaFromMtime(resolveClassMtime(PanelReferenceIndex::class)),
            ),
            [PanelReferenceResources::class, 'fieldsList'],
            true,
        );

        $sections = $panel->sectionsList();
        $registry->registerResource(
            new Resource(
                uri: 'kirby://sections',
                name: 'panel_sections',
                description: 'List Kirby Panel section types (links to kirby://section/{type}).',
                mimeType: 'text/markdown',
                annotations: $defaultAnnotations,
                size: strlen($sections),
                meta: resourceMetaFromMtime(resolveClassMtime(PanelReferenceIndex::class)),
            ),
            [PanelReferenceResources::class, 'sectionsList'],
            true,
        );
    } catch (Throwable) {
        // Keep resources available via attribute discovery if sizing fails.
    }

    try {
        $contents = (new GlossaryResources())->glossaryList();
        $registry->registerResource(
            new Resource(
                uri: 'kirby://glossary',
                name: 'glossary',
                description: 'List bundled Kirby glossary terms (links to kirby://glossary/{term}).',
                mimeType: 'text/markdown',
                annotations: $defaultAnnotations,
                size: strlen($contents),
                meta: resourceMetaFromMtime(resolveKbPrefixMtime('kb/kirby/glossary/')),
            ),
            [GlossaryResources::class, 'glossaryList'],
            true,
        );
    } catch (Throwable) {
        // Keep resource available via attribute discovery if sizing fails.
    }

    try {
        $contents = (new UpdateSchemaResources())->contentFieldsList();
        $registry->registerResource(
            new Resource(
                uri: 'kirby://fields/update-schema',
                name: 'update_schema_fields',
                description: 'List bundled content field update schemas (links to kirby://field/{type}/update-schema).',
                mimeType: 'text/markdown',
                annotations: $importantAnnotations,
                size: strlen($contents),
                meta: resourceMetaFromMtime(resolveKbPrefixMtime('kb/kirby/update-schema/')),
            ),
            [UpdateSchemaResources::class, 'contentFieldsList'],
            true,
        );
    } catch (Throwable) {
        // Keep resource available via attribute discovery if sizing fails.
    }

    try {
        $context = new ProjectContext();
        $projectRoot = $context->projectRoot();
        $lastModified = resolveProjectMtime($projectRoot);
        $size = null;

        try {
            $payload = (new CliResources($context))->commands();
            if (($payload['ok'] ?? false) === true) {
                $size = resolveJsonSize($payload);
            }
        } catch (Throwable) {
            // Ignore size calculation failures; still register metadata.
        }

        $registry->registerResource(
            new Resource(
                uri: 'kirby://commands',
                name: 'commands',
                description: 'Kirby CLI command list for this project (parsed from `kirby help`).',
                mimeType: 'application/json',
                annotations: $importantAnnotations,
                size: $size,
                meta: resourceMetaFromMtime($lastModified),
            ),
            [CliResources::class, 'commands'],
            true,
        );
    } catch (Throwable) {
        // Keep resource available via attribute discovery if registration fails.
    }
}

function resolveKirbyMcpVersion(): string
{
    $composerJson = dirname(__DIR__) . DIRECTORY_SEPARATOR . 'composer.json';
    $composerVersion = null;

    if (is_file($composerJson)) {
        $contents = file_get_contents($composerJson);
        if (is_string($contents) && trim($contents) !== '') {
            try {
                $decoded = json_decode($contents, true, flags: JSON_THROW_ON_ERROR);
                if (is_array($decoded)) {
                    $version = $decoded['version'] ?? null;
                    if (is_string($version) && trim($version) !== '') {
                        $composerVersion = trim($version);
                    }
                }
            } catch (Throwable) {
                // Ignore invalid JSON and fall back to other sources.
            }
        }
    }

    if (class_exists(\Composer\InstalledVersions::class)) {
        try {
            if (\Composer\InstalledVersions::isInstalled('bnomei/kirby-mcp')) {
                $pretty = \Composer\InstalledVersions::getPrettyVersion('bnomei/kirby-mcp');
                $reference = \Composer\InstalledVersions::getReference('bnomei/kirby-mcp');

                if (is_string($pretty) && $pretty !== '') {
                    $isDev = str_starts_with($pretty, 'dev-') || $pretty === 'dev-main' || $pretty === 'dev-master';
                    if ($isDev && is_string($composerVersion) && $composerVersion !== '') {
                        if (is_string($reference) && $reference !== '') {
                            return $composerVersion . '+' . substr($reference, 0, 7);
                        }

                        return $composerVersion;
                    }

                    if (is_string($reference) && $reference !== '') {
                        return $pretty . '+' . substr($reference, 0, 7);
                    }

                    return $pretty;
                }
            }
        } catch (Throwable) {
            // Fall through to file-based/versionless fallback.
        }
    }

    if (is_string($composerVersion) && $composerVersion !== '') {
        return $composerVersion;
    }

    return '0.0.0';
}

$container = new Container();
$registry = new Registry();
$referenceHandler = new ReferenceHandler($container);
$callToolHandler = new CallToolHandler($registry, $referenceHandler);

$builder = Server::builder()
    ->setContainer($container)
    ->setRegistry($registry)
    ->setServerInfo('Kirby MCP', resolveKirbyMcpVersion())
    ->setInstructions('Call kirby_init once per session before calling any other Kirby tools. Use kirby_tool_suggest if unsure which tool/resource to use.');

$server = $builder
    ->setDiscovery(dirname(__DIR__), ['src'])
    ->addRequestHandler(new RequireInitForToolsHandler($callToolHandler))
    ->addRequestHandler(new SetLogLevelHandler())
    ->setCapabilities(new ServerCapabilities(
        tools: true,
        resources: true,
        prompts: true,
        logging: true,
        completions: true,
    ))
    ->build();

registerSizedMarkdownResources($registry);

exit($server->run(new StdioTransport()));
